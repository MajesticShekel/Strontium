#type common
#version 440
/*
 * PBR shader program for a non-occluded point light. Follows the Filament
 * material system (somewhat).
 * https://google.github.io/filament/Filament.md.html#materialsystem/standardmodel
 * This is a stop-gap until tiled deferred rendering is implemented.
 */

#type vertex
layout (location = 0) in vec2 vPosition;

void main()
{
  gl_Position = vec4(vPosition.x, vPosition.y, 0.0, 1.0);
}

#type fragment
#define PI 3.141592654

// Camera specific uniforms.
layout(std140, binding = 0) uniform CameraBlock
{
  mat4 u_viewMatrix;
  mat4 u_projMatrix;
  vec3 u_camPosition;
};

// Directional light uniforms.
layout(std140, binding = 5) uniform PointBlock
{
  vec4 u_lColourIntensity;
  vec4 u_lPosition;
  vec4 u_screenSizeRadiusFalloff;
};

// Uniforms for the geometry buffer.
layout(binding = 3) uniform sampler2D gPosition;
layout(binding = 4) uniform sampler2D gNormal;
layout(binding = 5) uniform sampler2D gAlbedo;
layout(binding = 6) uniform sampler2D gMatProp;

// Output colour variable.
layout(location = 0) out vec4 fragColour;

// PBR BRDF.
vec3 filamentBRDF(vec3 l, vec3 v, vec3 n, float roughness, vec3 f0, vec3 f90, vec3 diffuseAlbedo);

// Compute the light attenuation factor.
float computeAttenuation(vec3 posToLight, float invLightRadius);

void main()
{
  vec2 fTexCoords = gl_FragCoord.xy / u_screenSizeRadiusFalloff.xy;

  vec3 position = texture(gPosition, fTexCoords).xyz;
  vec3 normal = normalize(texture(gNormal, fTexCoords).xyz);
  vec3 albedo = texture(gAlbedo, fTexCoords).rgb;
  float metallic = texture(gMatProp, fTexCoords).r;
  float roughness = texture(gMatProp, fTexCoords).g;
  float f0 = texture(gAlbedo, fTexCoords).a;

  // Remap material properties.
  vec3 diffuseAlbedo = (1.0 - metallic) * albedo;
  vec3 mappedF0 = vec3(f0) * (1.0 - metallic) + albedo * metallic;

  // Dirty, setting f90 to 1.0.
  vec3 f90 = vec3(1.0);

  // Light properties.
  vec3 view = normalize(u_camPosition - position);
  vec3 posToLight = u_lPosition.xyz - position;
  vec3 light = normalize(posToLight);
  vec3 halfWay = normalize(view + light);
  float nDotL = clamp(dot(normal, light), 0.0, 1.0);

  float lightRadius = u_screenSizeRadiusFalloff.z;
  float attenuation = computeAttenuation(posToLight, 1.0 / lightRadius);
  vec3 lightColour = u_lColourIntensity.xyz;
  float lightIntensity = u_lColourIntensity.w;

  // Compute the radiance contribution.
  vec3 radiance = filamentBRDF(light, view, normal, roughness, mappedF0, f90, diffuseAlbedo);
  radiance *= (lightIntensity * lightColour * nDotL * attenuation);

  radiance = max(radiance, vec3(0.0));
  fragColour = vec4(radiance, 1.0);
}

// Compute the light attenuation factor.
float computeAttenuation(vec3 posToLight, float invLightRadius)
{
  float distSquared = dot(posToLight, posToLight);
  float factor = distSquared * invLightRadius * invLightRadius;
  float smoothFactor = max(1.0 - factor * factor, 0.0);
  return (smoothFactor * smoothFactor) / max(distSquared, 1e-4);
}

//------------------------------------------------------------------------------
// Filament PBR.
//------------------------------------------------------------------------------
// Normal distribution function.
float nGGX(float nDotH, float actualRoughness)
{
  float a = nDotH * actualRoughness;
  float k = actualRoughness / (1.0 - nDotH * nDotH + a * a);
  return k * k * (1.0 / PI);
}

// Fast visibility term. Incorrect as it approximates the two square roots.
float vGGXFast(float nDotV, float nDotL, float actualRoughness)
{
  float a = actualRoughness;
  float vVGGX = nDotL * (nDotV * (1.0 - a) + a);
  float lVGGX = nDotV * (nDotL * (1.0 - a) + a);
  return 0.5 / (vVGGX + lVGGX);
}

// Schlick approximation for the Fresnel factor.
vec3 sFresnel(float vDotH, vec3 f0, vec3 f90)
{
  return f0 + (f90 - f0) * pow(1.0 - vDotH, 5.0);
}

// Cook-Torrance specular for the specular component of the BRDF.
vec3 fsCookTorrance(float nDotH, float lDotH, float nDotV, float nDotL,
                    float vDotH, float actualRoughness, vec3 f0, vec3 f90)
{
  float D = nGGX(nDotH, actualRoughness);
  vec3 F = sFresnel(vDotH, f0, f90);
  float V = vGGXFast(nDotV, nDotL, actualRoughness);
  return D * F * V;
}

// Burley diffuse for the diffuse component of the BRDF.
vec3 fdBurley(float nDotV, float nDotL, float lDotH, float actualRoughness, vec3 diffuseAlbedo)
{
  vec3 f90 = vec3(0.5 + 2.0 * actualRoughness * lDotH * lDotH);
  vec3 lightScat = sFresnel(nDotL, vec3(1.0), f90);
  vec3 viewScat = sFresnel(nDotV, vec3(1.0), f90);
  return lightScat * viewScat * (1.0 / PI) * diffuseAlbedo;
}

// The final combined BRDF.
// TODO: Fix conservation of energy between the diffuse and specular lobes.
// TODO: Compensate for energy loss by accounting for multi-scattering events.
vec3 filamentBRDF(vec3 l, vec3 v, vec3 n, float roughness, vec3 f0, vec3 f90, vec3 diffuseAlbedo)
{
  vec3 h = normalize(v + l);

  float nDotV = abs(dot(n, v)) + 1e-5;
  float nDotL = clamp(dot(n, l), 0.0, 1.0);
  float nDotH = clamp(dot(n, h), 0.0, 1.0);
  float lDotH = clamp(dot(l, h), 0.0, 1.0);
  float vDotH = clamp(dot(v, h), 0.0, 1.0);

  float clampedRoughness = max(roughness, 0.045);
  float actualRoughness = clampedRoughness * clampedRoughness;

  vec3 fs = fsCookTorrance(nDotH, lDotH, nDotV, nDotL, vDotH, actualRoughness, f0, f90);
  vec3 fd = fdBurley(nDotV, nDotL, lDotH, actualRoughness, diffuseAlbedo);
  return fd + fs;
}
